<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ECOD Structure Viewer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    #wrapper {
      width: 100%;
      height: 100%;
      position: relative;
    }
    /* Mol* renders into this container */
    #viewer-container {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
    }
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: #666;
      z-index: 1000;
      background: rgba(255,255,255,0.9);
      padding: 20px;
      border-radius: 8px;
    }
    #loading .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid #e5e7eb;
      border-top-color: #3b82f6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 12px;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    #error {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: #dc2626;
      padding: 20px;
      display: none;
      z-index: 1000;
      background: rgba(255,255,255,0.9);
      border-radius: 8px;
    }
    /* Bottom left controls - OUTSIDE viewer container */
    #controls {
      position: absolute;
      bottom: 8px;
      left: 8px;
      z-index: 1000;
      display: none;
      gap: 3px;
      background: rgba(255,255,255,0.95);
      border: 1px solid #d1d5db;
      border-radius: 6px;
      padding: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    #controls button {
      padding: 4px 8px;
      font-size: 11px;
      background: transparent;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      color: #4b5563;
      transition: all 0.15s;
    }
    #controls button:hover {
      background: #f3f4f6;
      color: #111827;
    }
    #controls button.active {
      background: #3b82f6;
      color: white;
    }
    #controls button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    #controls .divider {
      width: 1px;
      background: #e5e7eb;
      margin: 2px 4px;
    }
    /* Top left info - OUTSIDE viewer container */
    #info {
      position: absolute;
      top: 8px;
      left: 8px;
      z-index: 1000;
      background: rgba(255,255,255,0.95);
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 11px;
      color: #374151;
      border: 1px solid #d1d5db;
      display: none;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    #info .title {
      font-weight: 600;
      color: #111827;
    }
    #info .subtitle {
      color: #6b7280;
      font-family: monospace;
      font-size: 10px;
    }
    /* Hide Mol* default controls */
    .msp-viewport-controls,
    .msp-highlight-info {
      display: none !important;
    }
  </style>
  <!-- PDBe Mol* Viewer -->
  <link rel="stylesheet" type="text/css" href="https://www.ebi.ac.uk/pdbe/pdb-component-library/css/pdbe-molstar-3.1.3.css">
  <script type="text/javascript" src="https://www.ebi.ac.uk/pdbe/pdb-component-library/js/pdbe-molstar-plugin-3.1.3.js"></script>
</head>
<body>
  <!-- Wrapper contains everything -->
  <div id="wrapper">
    <!-- Mol* renders into this dedicated container -->
    <div id="viewer-container"></div>

    <!-- UI overlays - outside viewer container so Mol* can't touch them -->
    <div id="loading">
      <div class="spinner"></div>
      <div>Loading structure...</div>
    </div>
    <div id="error">
      <p style="font-size: 16px; margin-bottom: 8px;">Unable to load structure</p>
      <p id="error-detail" style="font-size: 12px; color: #666;"></p>
    </div>
    <div id="info">
      <div class="title" id="domain-label">Domain</div>
      <div class="subtitle" id="range-label"></div>
    </div>
    <div id="controls">
      <button onclick="setViewMode('domain')" id="mode-domain" class="active" title="Domain structure only">Domain</button>
      <button onclick="setViewMode('context')" id="mode-context" title="Domain in chain context">In Context</button>
      <div class="divider"></div>
      <button onclick="resetView()" title="Reset camera">Reset</button>
      <button onclick="toggleSpin()" id="spin-btn" title="Toggle rotation">Spin</button>
    </div>
  </div>

  <script>
    let viewerInstance = null;
    let isSpinning = false;
    let currentViewMode = 'domain';

    // Parse URL parameters
    const params = new URLSearchParams(window.location.search);
    const uid = params.get('uid');
    const pdbId = params.get('pdb');
    const chainId = params.get('chain');
    const range = params.get('range');
    const domainId = params.get('domain');
    const afId = params.get('af');
    const requestedMode = params.get('mode'); // 'domain' or 'context'

    console.log('Viewer params:', { uid, pdbId, chainId, range, domainId, afId, requestedMode });

    // Cleanup function to properly dispose viewer
    function destroyViewer() {
      console.log('destroyViewer called, viewerInstance:', !!viewerInstance);
      if (viewerInstance) {
        try {
          // Try to clear - don't await, just fire and forget
          if (typeof viewerInstance.clear === 'function') {
            viewerInstance.clear();
          }
        } catch (e) {
          console.warn('Error clearing viewer:', e);
        }
        viewerInstance = null;
      }
      // Clear the viewer container completely
      const container = document.getElementById('viewer-container');
      if (container) {
        container.innerHTML = '';
        console.log('Viewer container cleared');
      }
    }

    // Parse range string like "A:70-167" or "A:1-70,A:169-344" or "A:77P-119P"
    function parseRange(rangeStr) {
      if (!rangeStr) return [];
      const segments = [];
      const parts = rangeStr.split(',');
      for (const part of parts) {
        const match = part.trim().match(/([A-Za-z0-9]+):(-?\d+[A-Za-z]?)-(-?\d+[A-Za-z]?)/);
        if (match) {
          const startNum = parseInt(match[2]);
          const endNum = parseInt(match[3]);
          segments.push({
            chain: match[1],
            start: startNum,
            end: endNum
          });
        }
      }
      console.log('Parsed range:', rangeStr, '->', segments);
      return segments;
    }

    function showError(message) {
      document.getElementById('loading').style.display = 'none';
      document.getElementById('error').style.display = 'block';
      document.getElementById('error-detail').textContent = message || '';
    }

    function showViewer() {
      document.getElementById('loading').style.display = 'none';
      document.getElementById('controls').style.display = 'flex';

      if (domainId || range) {
        document.getElementById('info').style.display = 'block';
        document.getElementById('domain-label').textContent = domainId || 'Domain';
        document.getElementById('range-label').textContent = range || '';
      }
    }

    // Check if domain PDB file exists
    async function checkDomainPdbExists() {
      if (!uid) return false;
      try {
        const response = await fetch(`/api/domain/${uid}/pdb`, { method: 'HEAD' });
        return response.ok;
      } catch {
        return false;
      }
    }

    // Load domain-only structure (pre-cut PDB file)
    async function loadDomainStructure() {
      if (!uid) {
        showError('No domain UID provided');
        return false;
      }

      // Check if domain PDB exists, fall back to context view if not
      const pdbExists = await checkDomainPdbExists();
      if (!pdbExists) {
        console.log('Domain PDB not found, falling back to context view');
        if (pdbId || afId) {
          document.getElementById('mode-domain').disabled = true;
          document.getElementById('mode-domain').title = 'Pre-cut domain PDB not available';
          currentViewMode = 'context';
          document.getElementById('mode-domain').classList.remove('active');
          document.getElementById('mode-context').classList.add('active');
          return loadContextStructure();
        } else {
          showError('Domain structure not available');
          return false;
        }
      }

      destroyViewer();

      const container = document.getElementById('viewer-container');
      if (!container) {
        console.error('Viewer container not found');
        showError('Viewer container not found');
        return false;
      }

      console.log('Creating new PDBeMolstarPlugin for domain view');
      viewerInstance = new PDBeMolstarPlugin();

      const options = {
        customData: {
          url: `/api/domain/${uid}/pdb`,
          format: 'pdb'
        },
        hideControls: true,
        hideCanvasControls: ['selection', 'animation', 'controlToggle', 'controlInfo'],
        bgColor: { r: 255, g: 255, b: 255 },
        lighting: 'plastic',
        selectInteraction: false,
        pdbeLink: false,
        sequencePanel: false,
      };

      console.log('Loading domain structure with options:', options);

      // Set up load complete handler
      viewerInstance.events.loadComplete.subscribe(() => {
        console.log('Domain structure loaded successfully');
        showViewer();
      });

      // Set up error handler
      viewerInstance.events.error?.subscribe?.((e) => {
        console.error('Mol* error event:', e);
      });

      try {
        await viewerInstance.render(container, options);
        console.log('Domain render() completed');
      } catch (renderErr) {
        console.error('Error in render():', renderErr);
        showError('Failed to render structure: ' + renderErr.message);
        return false;
      }
      return true;
    }

    // Load full structure with domain highlighted
    async function loadContextStructure() {
      console.log('loadContextStructure called, pdbId:', pdbId, 'afId:', afId);

      if (!pdbId && !afId) {
        console.log('No pdbId or afId, falling back to domain view');
        return loadDomainStructure();
      }

      destroyViewer();

      const container = document.getElementById('viewer-container');
      if (!container) {
        console.error('Viewer container not found');
        showError('Viewer container not found');
        return false;
      }

      const segments = parseRange(range);

      console.log('Creating new PDBeMolstarPlugin for context view');
      viewerInstance = new PDBeMolstarPlugin();

      const options = {
        hideControls: true,
        hideCanvasControls: ['selection', 'animation', 'controlToggle', 'controlInfo'],
        bgColor: { r: 255, g: 255, b: 255 },
        lighting: 'plastic',
        selectInteraction: false,
        pdbeLink: false,
        sequencePanel: false,
      };

      if (pdbId) {
        options.moleculeId = pdbId.toLowerCase();
        console.log('Using moleculeId:', options.moleculeId);
      } else if (afId) {
        options.customData = {
          url: `https://alphafold.ebi.ac.uk/files/AF-${afId}-F1-model_v4.cif`,
          format: 'mmcif'
        };
        console.log('Using AlphaFold customData');
      }

      console.log('Loading context structure with options:', options);

      // Set up load complete handler
      viewerInstance.events.loadComplete.subscribe(() => {
        console.log('Context structure loaded successfully');
        showViewer();

        // Highlight domain region after a delay
        if (segments.length > 0) {
          setTimeout(() => highlightDomain(segments), 1000);
        }
      });

      // Set up error handler
      viewerInstance.events.error?.subscribe?.((e) => {
        console.error('Mol* error event:', e);
      });

      try {
        await viewerInstance.render(container, options);
        console.log('Context render() completed');
      } catch (renderErr) {
        console.error('Error in render():', renderErr);
        showError('Failed to render structure: ' + renderErr.message);
        return false;
      }
      return true;
    }

    // Highlight domain using visual.select
    async function highlightDomain(segments) {
      if (!viewerInstance) {
        console.warn('No viewer instance for highlighting');
        return;
      }

      console.log('Attempting to highlight segments:', segments);

      // Try multiple parameter naming conventions
      // PDBe Mol* has deprecated and canonical names
      for (const seg of segments) {
        const selections = [
          // Try canonical auth names (beg/end_auth_seq_id)
          {
            auth_asym_id: seg.chain,
            beg_auth_seq_id: seg.start,
            end_auth_seq_id: seg.end,
            color: { r: 234, g: 88, b: 12 },
          },
          // Try deprecated names (start/end_auth_residue_number)
          {
            auth_asym_id: seg.chain,
            start_auth_residue_number: seg.start,
            end_auth_residue_number: seg.end,
            color: { r: 234, g: 88, b: 12 },
          },
          // Try struct_asym_id with residue numbers (label coordinates)
          {
            struct_asym_id: seg.chain,
            start_residue_number: seg.start,
            end_residue_number: seg.end,
            color: { r: 234, g: 88, b: 12 },
          },
        ];

        for (let i = 0; i < selections.length; i++) {
          try {
            console.log(`Trying selection format ${i}:`, selections[i]);

            viewerInstance.visual.select({
              data: [selections[i]],
              nonSelectedColor: { r: 200, g: 200, b: 200 },
            });

            // If we get here without error, also try focus
            viewerInstance.visual.focus([{
              auth_asym_id: seg.chain,
              beg_auth_seq_id: seg.start,
              end_auth_seq_id: seg.end,
            }]);

            console.log(`Selection format ${i} succeeded`);
            return; // Stop trying once one works
          } catch (err) {
            console.warn(`Selection format ${i} failed:`, err.message);
          }
        }
      }

      console.error('All selection formats failed');
    }

    // Initialize viewer
    async function initViewer() {
      console.log('Initializing viewer');

      if (!uid && !pdbId && !afId) {
        showError('No structure identifier provided');
        return;
      }

      try {
        // Determine which mode to use
        // If mode=context requested, or no UID available, use context mode
        const useContextMode = requestedMode === 'context' || !uid;

        if (useContextMode) {
          currentViewMode = 'context';
          document.getElementById('mode-domain').classList.remove('active');
          document.getElementById('mode-context').classList.add('active');
          await loadContextStructure();
        } else {
          // Default to domain mode when UID is available
          currentViewMode = 'domain';
          await loadDomainStructure();
        }
      } catch (error) {
        console.error('Viewer initialization error:', error);
        showError(error.message || 'Failed to initialize viewer');
      }
    }

    // Switch view modes by reloading page with different params
    // (Mol* doesn't handle destroy/recreate well due to global state)
    function setViewMode(mode) {
      if (mode === currentViewMode) return;

      const domainBtn = document.getElementById('mode-domain');
      if (mode === 'domain' && domainBtn.disabled) return;

      // Build new URL with mode parameter
      const newParams = new URLSearchParams(window.location.search);
      newParams.set('mode', mode);

      // Reload page with new mode
      window.location.search = newParams.toString();
    }

    function resetView() {
      if (viewerInstance) {
        viewerInstance.visual.reset({ camera: true });
      }
    }

    function toggleSpin() {
      if (viewerInstance) {
        isSpinning = !isSpinning;
        viewerInstance.visual.toggleSpin(isSpinning);
        document.getElementById('spin-btn').classList.toggle('active', isSpinning);
      }
    }

    // Listen for messages from parent iframe
    window.addEventListener('message', (event) => {
      if (!event.data || event.data.target !== 'ecod-viewer') return;
      const { action, value } = event.data;
      switch (action) {
        case 'reset': resetView(); break;
        case 'spin': toggleSpin(); break;
        case 'viewMode': setViewMode(value); break;
      }
    });

    // Initialize on DOM ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initViewer);
    } else {
      initViewer();
    }

    // Cleanup on page unload
    window.addEventListener('beforeunload', destroyViewer);
  </script>
</body>
</html>
